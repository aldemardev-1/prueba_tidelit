# üìö Prueba T√©cnica: Plataforma de Libros y Rese√±as

Este proyecto es una implementaci√≥n de una prueba t√©cnica que consiste en una API RESTful b√°sica desarrollada con **Symfony 6** y un frontend simple para consumirla construido con **Vue.js 3, TypeScript y Tailwind CSS**. El objetivo es demostrar la capacidad para estructurar un proyecto limpio, trabajar con relaciones entre entidades, crear migraciones y exponer un endpoint funcional que es consumido por una interfaz de usuario moderna.

## üöÄ Caracter√≠sticas Implementadas

### Backend (Symfony 6)

* **Modelos de Entidades:**
    * **`Book`**: `id`, `title`, `author`, `published_year`.
    * **`Review`**: `id`, `book_id` (relaci√≥n ManyToOne con Book), `rating` (int de 1 a 5), `comment` (text), `created_at` (datetime).
* **Doctrine ORM:** Utilizado para la definici√≥n de entidades y la gesti√≥n de migraciones de base de datos.
* **Endpoints API:**
    * `GET /api/books`: Devuelve una lista de libros con sus datos y el promedio de rating calculado eficientemente usando Doctrine DQL.
    * `POST /api/reviews`: Permite registrar una rese√±a para un libro. Incluye validaciones b√°sicas (rating entre 1 y 5, `book_id` debe existir, `comment` no puede estar vac√≠o).
* **Fixtures:** Incluye 3 libros y al menos 6 rese√±as precargadas en la base de datos utilizando Doctrine Fixtures.
* **CORS:** Configurado para permitir la comunicaci√≥n entre el frontend y el backend en diferentes puertos.

### Frontend (Vue.js 3 + TypeScript + Tailwind CSS)

* **Componentizaci√≥n:** Aplicaci√≥n modularizada en componentes reutilizables (`App.vue`, `BookList.vue`, `BookCard.vue`, `AddReviewForm.vue`).
* **Composition API:** Utiliza la Composition API de Vue 3 (`<script setup>`) para una l√≥gica de componentes organizada y reutilizable.
* **TypeScript:** Tipado est√°tico en todo el frontend para mejorar la robustez del c√≥digo y la experiencia de desarrollo.
* **Tailwind CSS:** Estilado r√°pido, responsivo y personalizable directamente en el marcado HTML/Vue, siguiendo un dise√±o limpio y moderno.
* **Cliente HTTP:** Utiliza `axios` encapsulado en un servicio (`src/services/api.ts`) para todas las interacciones con la API, incluyendo interceptores para un manejo centralizado.
* **Manejo de Estados:** Muestra estados de carga, error y mensajes de √©xito/validaci√≥n al usuario.

## üìÇ Estructura del Proyecto (Monorepo)

```
.
‚îú‚îÄ‚îÄ symfony_vue_challenge/   # Directorio del Backend Symfony
‚îÇ   ‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Controller/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ApiController.php
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Entity/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Book.php
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Review.php
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Repository/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BookRepository.php
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ReviewRepository.php
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DataFixtures/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ BookFixtures.php
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ReviewFixtures.php
‚îÇ   ‚îú‚îÄ‚îÄ migrations/
‚îÇ   ‚îú‚îÄ‚îÄ var/                 # Ignorado por Git (cach√©, logs, data.db)
‚îÇ   ‚îú‚îÄ‚îÄ .env                 # Ignorado por Git (usar .env.dist o .env.example)
‚îÇ   ‚îî‚îÄ‚îÄ composer.json
‚îú‚îÄ‚îÄ my-vue-book-app/         # Directorio del Frontend Vue.js
‚îÇ   ‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ assets/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.css     # Estilos globales de Tailwind
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BookCard.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BookList.vue
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ AddReviewForm.vue
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ api.ts       # Cliente HTTP (Axios)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ index.ts     # Definiciones de interfaces TypeScript
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ App.vue
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ main.ts          # Punto de entrada de Vue
‚îÇ   ‚îú‚îÄ‚îÄ dist/                # Ignorado por Git (build de producci√≥n)
‚îÇ   ‚îú‚îÄ‚îÄ node_modules/        # Ignorado por Git (dependencias)
‚îÇ   ‚îú‚îÄ‚îÄ package.json
‚îÇ   ‚îú‚îÄ‚îÄ tsconfig.json
‚îÇ   ‚îú‚îÄ‚îÄ vite.config.ts
‚îÇ   ‚îú‚îÄ‚îÄ tailwind.config.js
‚îÇ   ‚îî‚îÄ‚îÄ postcss.config.js
‚îî‚îÄ‚îÄ .gitignore               # Archivo de ignorados para Git (√∫nico para todo el monorepo)
```

## ‚öôÔ∏è Instrucciones de Instalaci√≥n y Ejecuci√≥n

Sigue estos pasos para configurar y ejecutar ambos proyectos en tu entorno local.

### Requisitos Previos

* **PHP 8.1+** (con extensiones `php_sqlite3` y `php_pdo_sqlite` habilitadas en `php.ini`, especialmente si usas XAMPP/WAMP).
* **Composer** (gestor de dependencias de PHP).
* **Node.js (LTS recomendado)** y **npm** (gestor de paquetes de Node.js).
* **Symfony CLI** (opcional, pero recomendado para `symfony serve`).

### 1. Configuraci√≥n del Backend (Symfony)

1.  **Clonar el Repositorio:**
    ```bash
    git clone https://github.com/aldemardev-1/prueba_tidelit.git
    cd prueba_tidelit
    ```

2.  **Instalar Dependencias de Composer:**
    Navega al directorio del backend:
    ```bash
    cd symfony_vue_challenge
    composer install
    ```
    * Si el comando `php bin/console make:...` no funciona, es posible que necesites instalar `MakerBundle`:
        ```bash
        composer require symfony/maker-bundle --dev
        ```

3.  **Configurar la Base de Datos:**
    El proyecto est√° configurado para usar **SQLite** por defecto. La base de datos se crear√° en `symfony_vue_challenge/var/data.db`.
    Aseg√∫rate de que la l√≠nea `DATABASE_URL` en `symfony_vue_challenge/.env` apunte a SQLite y no haya otras l√≠neas `DATABASE_URL` activas que apunten a PostgreSQL o MySQL.

    ```dotenv
    # symfony_vue_challenge/.env
    DATABASE_URL="sqlite:///%kernel.project_dir%/var/data.db"
    ```

4.  **Ejecutar Migraciones de Base de Datos:**
    Esto crear√° las tablas `book` y `review` en tu base de datos SQLite.
    ```bash
    php bin/console make:migration # Si es la primera vez o has cambiado entidades
    php bin/console doctrine:migrations:migrate
    ```

5.  **Cargar Datos de Prueba (Fixtures):**
    Esto insertar√° 3 libros y 6 rese√±as de ejemplo.
    ```bash
    php bin/console doctrine:fixtures:load
    ```
    * Si tienes problemas con `getReference()` en los fixtures, aseg√∫rate de que en `src/DataFixtures/ReviewFixtures.php` la llamada sea `this->getReference('nombre_referencia', App\Entity\Book::class)`.

6.  **Iniciar el Servidor Symfony:**
    ```bash
    symfony serve
    ```
    El API estar√° disponible en `http://127.0.0.1:8000` (o el puerto que te indique Symfony CLI).

### 2. Configuraci√≥n del Frontend (Vue.js)

1.  **Navegar al Directorio del Frontend:**
    Abre una **nueva terminal** y navega al directorio del frontend desde la ra√≠z de tu monorepo:
    ```bash
    cd my-vue-book-app
    ```

2.  **Instalar Dependencias de Node:**
    ```bash
    npm install
    ```

3.  **Iniciar el Servidor de Desarrollo de Vue:**
    ```bash
    npm run dev
    ```
    El frontend estar√° disponible en `http://localhost:5173` (o un puerto similar que te indique Vite).

    **¬°Importante!** Aseg√∫rate de que el backend Symfony (`http://127.0.0.1:8000`) est√© funcionando **antes** de iniciar el frontend, ya que este √∫ltimo intentar√° consumir el API desde esa direcci√≥n.

## üì∏ Captura de Pantalla del API

![imagen de books endpoint](/imgs/books_endpoint.png)
![imagen de reviews_post](/imgs/reviews_post.png)


### Endpoint: `GET /api/books`

Puedes acceder a este endpoint directamente en tu navegador despu√©s de iniciar el servidor Symfony: `http://127.0.0.1:8000/api/books`

**Ejemplo de respuesta JSON:**

```json
[
  {
    "id": 1,
    "title": "El Arte de Programar",
    "author": "Donald Knuth",
    "published_year": 1968,
    "average_rating": 4.5
  },
  {
    "id": 2,
    "title": "Clean Code",
    "author": "Robert C. Martin",
    "published_year": 2008,
    "average_rating": 4.5
  },
  {
    "id": 3,
    "title": "Domain-Driven Design",
    "author": "Eric Evans",
    "published_year": 2003,
    "average_rating": 4.5
  }
]
```

### Vista Previa del Frontend

![imagen del frontend 1](/imgs/frontend_1.png)
![imagen del frontend 2](/imgs/frontend_2.png)

## üìà Pregunta Opcional: Estrategias de Escalabilidad del API

Si esta aplicaci√≥n tuviera que escalar a una plataforma p√∫blica con cientos de miles de libros y millones de usuarios, se necesitar√≠an cambios significativos para garantizar rendimiento, disponibilidad y mantenibilidad. Aqu√≠ algunos puntos clave:

1.  **Base de Datos:**
    * **Migraci√≥n a una DB robusta:** Pasar de SQLite a PostgreSQL o MySQL (o una base de datos NoSQL si el modelo de datos lo justifica). Son bases de datos de producci√≥n mucho m√°s escalables, con mejor manejo de concurrencia, replicaci√≥n y herramientas de monitoreo.
    * **Optimizaci√≥n de Consultas e √çndices:** A√±adir √≠ndices a columnas frecuentemente consultadas (ej. `book_id` en `reviews`) y optimizar consultas complejas. Considerar vistas materializadas para c√°lculos agregados (como `average_rating`) que no necesitan ser en tiempo real absoluto.
    * **Sharding/Replicaci√≥n:** Distribuir los datos y la carga entre m√∫ltiples instancias de base de datos.

2.  **Cach√©:**
    * **Cache de Resultados de API (Full Page/Fragment Caching):** Implementar una capa de cach√© (ej. Redis, Memcached, Varnish) para el endpoint `GET /api/books`. Los datos de los libros y sus promedios no cambian constantemente, por lo que se pueden cachear por un tiempo determinado, invalidando el cach√© solo cuando se a√±ade/modifica una rese√±a a un libro.
    * **Cache de Consultas Doctrine:** Utilizar las capacidades de cach√© de Doctrine para reducir las consultas a la base de datos.

3.  **Rendimiento del API (Symfony):**
    * **Paginaci√≥n:** Es inviable devolver todos los libros de una sola vez. Implementar paginaci√≥n (`limit`, `offset`, o basados en cursor) para el endpoint `/api/books`.
    * **Throttling/Rate Limiting:** Limitar el n√∫mero de solicitudes que un usuario o IP puede hacer en un per√≠odo de tiempo para prevenir abusos y ataques DDoS.
    * **Queues (Colas de Mensajes):** Para operaciones que no requieren una respuesta inmediata (ej. procesamiento de rese√±as complejas, env√≠o de notificaciones), usar colas de mensajes (RabbitMQ, Kafka, AWS SQS) para procesarlas asincr√≥nicamente y no bloquear la respuesta del API.
    * **Serializaci√≥n Eficiente:** Optimizar la serializaci√≥n de las respuestas JSON para enviar solo los datos necesarios y en el formato m√°s eficiente.

4.  **Infraestructura y Despliegue:**
    * **Balanceo de Carga:** Distribuir las solicitudes entrantes entre m√∫ltiples instancias del API para manejar un alto tr√°fico.
    * **Contenerizaci√≥n (Docker) y Orquestaci√≥n (Kubernetes):** Empaquetar la aplicaci√≥n en contenedores facilita el despliegue, la escalabilidad horizontal y la gesti√≥n en entornos de producci√≥n complejos.
    * **CDN (Content Delivery Network):** Para servir los activos est√°ticos del frontend (im√°genes, CSS, JS) desde ubicaciones geogr√°ficas m√°s cercanas a los usuarios, reduciendo la latencia.
    * **Separaci√≥n de Repositorios (Polyrepo):** Aunque para esta prueba usamos un monorepo, a gran escala, separar el frontend y el backend en repositorios distintos permitir√≠a a equipos independientes trabajar y desplegar de forma aut√≥noma.

5.  **Seguridad y Monitoreo:**
    * **Autenticaci√≥n y Autorizaci√≥n Robustas:** Implementar un sistema de registro de usuarios, login (OAuth2, JWT) y roles/permisos m√°s sofisticado (ej. solo usuarios autenticados pueden dejar rese√±as, administradores pueden gestionar libros).
    * **Monitoreo y Logging:** Implementar herramientas de monitoreo de rendimiento (APM) y un sistema de logging centralizado para detectar y diagnosticar problemas r√°pidamente.

En resumen, la escalabilidad implicar√≠a una evoluci√≥n de una arquitectura monol√≠tica simple a una distribuida, con capas de cach√©, balanceo de carga, optimizaciones de base de datos y un enfoque en la resiliencia y la seguridad para manejar el volumen y la concurrencia de una plataforma p√∫blica.
