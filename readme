# ğŸ“š Prueba TÃ©cnica: Plataforma de Libros y ReseÃ±as

Este proyecto es una implementaciÃ³n de una prueba tÃ©cnica que consiste en una API RESTful bÃ¡sica desarrollada con **Symfony 6** y un frontend simple para consumirla construido con **Vue.js 3, TypeScript y Tailwind CSS**. El objetivo es demostrar la capacidad para estructurar un proyecto limpio, trabajar con relaciones entre entidades, crear migraciones y exponer un endpoint funcional que es consumido por una interfaz de usuario moderna.

## ğŸš€ CaracterÃ­sticas Implementadas

### Backend (Symfony 6)

* **Modelos de Entidades:**
    * **`Book`**: `id`, `title`, `author`, `published_year`.
    * **`Review`**: `id`, `book_id` (relaciÃ³n ManyToOne con Book), `rating` (int de 1 a 5), `comment` (text), `created_at` (datetime).
* **Doctrine ORM:** Utilizado para la definiciÃ³n de entidades y la gestiÃ³n de migraciones de base de datos.
* **Endpoints API:**
    * `GET /api/books`: Devuelve una lista de libros con sus datos y el promedio de rating calculado eficientemente usando Doctrine DQL.
    * `POST /api/reviews`: Permite registrar una reseÃ±a para un libro. Incluye validaciones bÃ¡sicas (rating entre 1 y 5, `book_id` debe existir, `comment` no puede estar vacÃ­o).
* **Fixtures:** Incluye 3 libros y al menos 6 reseÃ±as precargadas en la base de datos utilizando Doctrine Fixtures.
* **CORS:** Configurado para permitir la comunicaciÃ³n entre el frontend y el backend en diferentes puertos.

### Frontend (Vue.js 3 + TypeScript + Tailwind CSS)

* **ComponentizaciÃ³n:** AplicaciÃ³n modularizada en componentes reutilizables (`App.vue`, `BookList.vue`, `BookCard.vue`, `AddReviewForm.vue`).
* **Composition API:** Utiliza la Composition API de Vue 3 (`<script setup>`) para una lÃ³gica de componentes organizada y reutilizable.
* **TypeScript:** Tipado estÃ¡tico en todo el frontend para mejorar la robustez del cÃ³digo y la experiencia de desarrollo.
* **Tailwind CSS:** Estilado rÃ¡pido, responsivo y personalizable directamente en el marcado HTML/Vue, siguiendo un diseÃ±o limpio y moderno.
* **Cliente HTTP:** Utiliza `axios` encapsulado en un servicio (`src/services/api.ts`) para todas las interacciones con la API, incluyendo interceptores para un manejo centralizado.
* **Manejo de Estados:** Muestra estados de carga, error y mensajes de Ã©xito/validaciÃ³n al usuario.

## ğŸ“‚ Estructura del Proyecto (Monorepo)

```
.
â”œâ”€â”€ symfony_vue_challenge/   # Directorio del Backend Symfony
â”‚   â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ Controller/
â”‚   â”‚   â”‚   â””â”€â”€ ApiController.php
â”‚   â”‚   â”œâ”€â”€ Entity/
â”‚   â”‚   â”‚   â”œâ”€â”€ Book.php
â”‚   â”‚   â”‚   â””â”€â”€ Review.php
â”‚   â”‚   â”œâ”€â”€ Repository/
â”‚   â”‚   â”‚   â”œâ”€â”€ BookRepository.php
â”‚   â”‚   â”‚   â””â”€â”€ ReviewRepository.php
â”‚   â”‚   â””â”€â”€ DataFixtures/
â”‚   â”‚       â”œâ”€â”€ BookFixtures.php
â”‚   â”‚       â””â”€â”€ ReviewFixtures.php
â”‚   â”œâ”€â”€ migrations/
â”‚   â”œâ”€â”€ var/                 # Ignorado por Git (cachÃ©, logs, data.db)
â”‚   â”œâ”€â”€ .env                 # Ignorado por Git (usar .env.dist o .env.example)
â”‚   â””â”€â”€ composer.json
â”œâ”€â”€ my-vue-book-app/         # Directorio del Frontend Vue.js
â”‚   â”œâ”€â”€ public/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ assets/
â”‚   â”‚   â”‚   â””â”€â”€ main.css     # Estilos globales de Tailwind
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ BookCard.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ BookList.vue
â”‚   â”‚   â”‚   â””â”€â”€ AddReviewForm.vue
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â””â”€â”€ api.ts       # Cliente HTTP (Axios)
â”‚   â”‚   â”‚   â””â”€â”€ types/
â”‚   â”‚   â”‚       â””â”€â”€ index.ts     # Definiciones de interfaces TypeScript
â”‚   â”‚   â”œâ”€â”€ App.vue
â”‚   â”‚   â””â”€â”€ main.ts          # Punto de entrada de Vue
â”‚   â”œâ”€â”€ dist/                # Ignorado por Git (build de producciÃ³n)
â”‚   â”œâ”€â”€ node_modules/        # Ignorado por Git (dependencias)
â”‚   â”œâ”€â”€ package.json
â”‚   â”œâ”€â”€ tsconfig.json
â”‚   â”œâ”€â”€ vite.config.ts
â”‚   â”œâ”€â”€ tailwind.config.js
â”‚   â””â”€â”€ postcss.config.js
â””â”€â”€ .gitignore               # Archivo de ignorados para Git (Ãºnico para todo el monorepo)
```

## âš™ï¸ Instrucciones de InstalaciÃ³n y EjecuciÃ³n

Sigue estos pasos para configurar y ejecutar ambos proyectos en tu entorno local.

### Requisitos Previos

* **PHP 8.1+** (con extensiones `php_sqlite3` y `php_pdo_sqlite` habilitadas en `php.ini`, especialmente si usas XAMPP/WAMP).
* **Composer** (gestor de dependencias de PHP).
* **Node.js (LTS recomendado)** y **npm** (gestor de paquetes de Node.js).
* **Symfony CLI** (opcional, pero recomendado para `symfony serve`).

### 1. ConfiguraciÃ³n del Backend (Symfony)

1.  **Clonar el Repositorio:**
    ```bash
    git clone <URL_DE_TU_REPOSITORIO_GITHUB>
    cd <nombre_de_tu_repositorio_clonado>
    ```

2.  **Instalar Dependencias de Composer:**
    Navega al directorio del backend:
    ```bash
    cd symfony_vue_challenge
    composer install
    ```
    * Si el comando `php bin/console make:...` no funciona, es posible que necesites instalar `MakerBundle`:
        ```bash
        composer require symfony/maker-bundle --dev
        ```

3.  **Configurar la Base de Datos:**
    El proyecto estÃ¡ configurado para usar **SQLite** por defecto. La base de datos se crearÃ¡ en `symfony_vue_challenge/var/data.db`.
    AsegÃºrate de que la lÃ­nea `DATABASE_URL` en `symfony_vue_challenge/.env` apunte a SQLite y no haya otras lÃ­neas `DATABASE_URL` activas que apunten a PostgreSQL o MySQL.

    ```dotenv
    # symfony_vue_challenge/.env
    DATABASE_URL="sqlite:///%kernel.project_dir%/var/data.db"
    ```

4.  **Ejecutar Migraciones de Base de Datos:**
    Esto crearÃ¡ las tablas `book` y `review` en tu base de datos SQLite.
    ```bash
    php bin/console make:migration # Si es la primera vez o has cambiado entidades
    php bin/console doctrine:migrations:migrate
    ```

5.  **Cargar Datos de Prueba (Fixtures):**
    Esto insertarÃ¡ 3 libros y 6 reseÃ±as de ejemplo.
    ```bash
    php bin/console doctrine:fixtures:load
    ```
    * Si tienes problemas con `getReference()` en los fixtures, asegÃºrate de que en `src/DataFixtures/ReviewFixtures.php` la llamada sea `this->getReference('nombre_referencia', App\Entity\Book::class)`.

6.  **Iniciar el Servidor Symfony:**
    ```bash
    symfony serve
    ```
    El API estarÃ¡ disponible en `http://127.0.0.1:8000` (o el puerto que te indique Symfony CLI).

### 2. ConfiguraciÃ³n del Frontend (Vue.js)

1.  **Navegar al Directorio del Frontend:**
    Abre una **nueva terminal** y navega al directorio del frontend desde la raÃ­z de tu monorepo:
    ```bash
    cd my-vue-book-app
    ```

2.  **Instalar Dependencias de Node:**
    ```bash
    npm install
    ```

3.  **Iniciar el Servidor de Desarrollo de Vue:**
    ```bash
    npm run dev
    ```
    El frontend estarÃ¡ disponible en `http://localhost:5173` (o un puerto similar que te indique Vite).

    **Â¡Importante!** AsegÃºrate de que el backend Symfony (`http://127.0.0.1:8000`) estÃ© funcionando **antes** de iniciar el frontend, ya que este Ãºltimo intentarÃ¡ consumir el API desde esa direcciÃ³n.

## ğŸ“¸ Captura de Pantalla del API y Frontend en AcciÃ³n

### Endpoint: `GET /api/books`

Puedes acceder a este endpoint directamente en tu navegador despuÃ©s de iniciar el servidor Symfony: `http://127.0.0.1:8000/api/books`

**Ejemplo de respuesta JSON:**

```json
[
  {
    "id": 1,
    "title": "El Arte de Programar",
    "author": "Donald Knuth",
    "published_year": 1968,
    "average_rating": 4.5
  },
  {
    "id": 2,
    "title": "Clean Code",
    "author": "Robert C. Martin",
    "published_year": 2008,
    "average_rating": 4.5
  },
  {
    "id": 3,
    "title": "Domain-Driven Design",
    "author": "Eric Evans",
    "published_year": 2003,
    "average_rating": 4.5
  }
]
```

### Vista Previa del Frontend



## ğŸ“ˆ Pregunta Opcional: Estrategias de Escalabilidad del API

Si esta aplicaciÃ³n tuviera que escalar a una plataforma pÃºblica con cientos de miles de libros y millones de usuarios, se necesitarÃ­an cambios significativos para garantizar rendimiento, disponibilidad y mantenibilidad. AquÃ­ algunos puntos clave:

1.  **Base de Datos:**
    * **MigraciÃ³n a una DB robusta:** Pasar de SQLite a PostgreSQL o MySQL (o una base de datos NoSQL si el modelo de datos lo justifica). Son bases de datos de producciÃ³n mucho mÃ¡s escalables, con mejor manejo de concurrencia, replicaciÃ³n y herramientas de monitoreo.
    * **OptimizaciÃ³n de Consultas e Ãndices:** AÃ±adir Ã­ndices a columnas frecuentemente consultadas (ej. `book_id` en `reviews`) y optimizar consultas complejas. Considerar vistas materializadas para cÃ¡lculos agregados (como `average_rating`) que no necesitan ser en tiempo real absoluto.
    * **Sharding/ReplicaciÃ³n:** Distribuir los datos y la carga entre mÃºltiples instancias de base de datos.

2.  **CachÃ©:**
    * **Cache de Resultados de API (Full Page/Fragment Caching):** Implementar una capa de cachÃ© (ej. Redis, Memcached, Varnish) para el endpoint `GET /api/books`. Los datos de los libros y sus promedios no cambian constantemente, por lo que se pueden cachear por un tiempo determinado, invalidando el cachÃ© solo cuando se aÃ±ade/modifica una reseÃ±a a un libro.
    * **Cache de Consultas Doctrine:** Utilizar las capacidades de cachÃ© de Doctrine para reducir las consultas a la base de datos.

3.  **Rendimiento del API (Symfony):**
    * **PaginaciÃ³n:** Es inviable devolver todos los libros de una sola vez. Implementar paginaciÃ³n (`limit`, `offset`, o basados en cursor) para el endpoint `/api/books`.
    * **Throttling/Rate Limiting:** Limitar el nÃºmero de solicitudes que un usuario o IP puede hacer en un perÃ­odo de tiempo para prevenir abusos y ataques DDoS.
    * **Queues (Colas de Mensajes):** Para operaciones que no requieren una respuesta inmediata (ej. procesamiento de reseÃ±as complejas, envÃ­o de notificaciones), usar colas de mensajes (RabbitMQ, Kafka, AWS SQS) para procesarlas asincrÃ³nicamente y no bloquear la respuesta del API.
    * **SerializaciÃ³n Eficiente:** Optimizar la serializaciÃ³n de las respuestas JSON para enviar solo los datos necesarios y en el formato mÃ¡s eficiente.

4.  **Infraestructura y Despliegue:**
    * **Balanceo de Carga:** Distribuir las solicitudes entrantes entre mÃºltiples instancias del API para manejar un alto trÃ¡fico.
    * **ContenerizaciÃ³n (Docker) y OrquestaciÃ³n (Kubernetes):** Empaquetar la aplicaciÃ³n en contenedores facilita el despliegue, la escalabilidad horizontal y la gestiÃ³n en entornos de producciÃ³n complejos.
    * **CDN (Content Delivery Network):** Para servir los activos estÃ¡ticos del frontend (imÃ¡genes, CSS, JS) desde ubicaciones geogrÃ¡ficas mÃ¡s cercanas a los usuarios, reduciendo la latencia.
    * **SeparaciÃ³n de Repositorios (Polyrepo):** Aunque para esta prueba usamos un monorepo, a gran escala, separar el frontend y el backend en repositorios distintos permitirÃ­a a equipos independientes trabajar y desplegar de forma autÃ³noma.

5.  **Seguridad y Monitoreo:**
    * **AutenticaciÃ³n y AutorizaciÃ³n Robustas:** Implementar un sistema de registro de usuarios, login (OAuth2, JWT) y roles/permisos mÃ¡s sofisticado (ej. solo usuarios autenticados pueden dejar reseÃ±as, administradores pueden gestionar libros).
    * **Monitoreo y Logging:** Implementar herramientas de monitoreo de rendimiento (APM) y un sistema de logging centralizado para detectar y diagnosticar problemas rÃ¡pidamente.

En resumen, la escalabilidad implicarÃ­a una evoluciÃ³n de una arquitectura monolÃ­tica simple a una distribuida, con capas de cachÃ©, balanceo de carga, optimizaciones de base de datos y un enfoque en la resiliencia y la seguridad para manejar el volumen y la concurrencia de una plataforma pÃºblica.
